/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

#include "symmetry_kit/find_symmetry_utils.hpp"
#include "symmetry_kit/symmetry_info.hpp"

namespace niedoida {
    namespace symmetry {
        void
        SymmetryInfo::find_symmetry_spheric_top(const arma::mat& passed_coords,
                                                const std::vector<unsigned>& q,
                                                double tol_dist)
        {

            arma::mat coords = passed_coords;

            Cn_axis_info Cn_principal;
            arma::vec principal_sigma_v;
            const my_fancy_compare compare_vectors(tol_dist);
            VectorSet sigma_planes(compare_vectors);

            const my_fancy_compare_axes compare_axes(tol_dist);
            AxisSet Cn_axes(compare_axes);

            _symmetry_type = NON_LINEAR_SYMMETRY;
            _top_type = SPHERIC_TOP;

            // General remarks concerning symmetry planes:
            // all symmetry planes must pass through OXYZ
            // There are two possibilities:
            //   1. Molecule is planar, then all atoms lie in the symmetry
            //   plane, or
            //   2. The symmetry plane is symmetral of some pair of atoms: seek
            //   for the symmetry planes among the
            //      planes perpendicular to the half-vector generated by all
            //      pairs of points
            //  The option "1." is excluded here due to the Inertia tensor being
            //  spherical

            // 1. find the principal axis:
            const boost::optional<Cn_axis_info> maybe_Cn_principal =
                find_principal_axis(coords, q, tol_dist);

            TransAcc tacc;

            if (maybe_Cn_principal) {
                Cn_principal = *maybe_Cn_principal;
                // 2. reorient the coords so that principal axis || "Z"
                coords =
                    align(coords, Cn_principal.vec, Z_AXIS, tol_dist, &tacc);
                // 3. find the principal axis again (with new orientation):
                Cn_principal = *find_principal_axis(coords, q, tol_dist);

                // 4. find the principal plane:
                // FIXME: looks fishy - to me it seems that we should check for
                // symmetry planes iff there's principal axis
                // not so clear to me (W.P.): what in case of accidentally
                // spheric top?
                boost::optional<arma::vec> maybe_principal_sigma_v =
                    find_principal_sigma_v(
                        coords, q, Cn_principal.vec, tol_dist);

                // 5. reorient the coords so that principal plane is "XZ" plane
                if (maybe_principal_sigma_v) {
                    principal_sigma_v = *maybe_principal_sigma_v;
                    coords = align(
                        coords, principal_sigma_v, Y_AXIS, tol_dist, &tacc);

                    // 6. find the principal plane again (with new orientation).
                    //   The principal axis remained untouched so there is no
                    //   need to recompute it
                    principal_sigma_v = *find_principal_sigma_v(
                        coords, q, Cn_principal.vec, tol_dist);
                }
            }

            // Here the molecule is in its standard orientation.
            // 7. Now find the rest of the axes and planes:
            // first, deal with pairs, i.e. with C2 axes.
            const std::size_t coords_len = coords.n_cols;
            for (unsigned i = 0; i < coords_len; ++i) {
                for (unsigned j = i + 1; j < coords_len; ++j) {
                    // find C2 axes symmetral to the pair of points: "first" and
                    // "second"
                    const arma::vec& first = coords.col(i);
                    const arma::vec& second = coords.col(j);
                    const arma::vec midpoint = (first + second) / 2;
                    const arma::vec normal_v = arma::norm(midpoint, 2) > 1e-10
                                                   ? normalise(midpoint, 2)
                                                   : normalise(first, 2);

                    // check for existence of C2 and S4
                    Cn_axis_info axis_info = {canonic(normal_v), 2};
                    if (are_equivalent(coords,
                                       rotate_axis_angle(coords, axis_info),
                                       q,
                                       tol_dist)) {
                        Cn_axes.insert(axis_info);
                        axis_info.fold = -2 * 2;
                        if (are_equivalent(coords,
                                           rotate_axis_angle(coords, axis_info),
                                           q,
                                           tol_dist)) {
                            Cn_axes.insert(axis_info);
                        }
                    }

                    // Seek for symmetry planes: given "midpoint" vector
                    // generate plane perpendicular to it
                    //   1. check whether the plane contains OXYZ (it is cheap)
                    //   2. if so, check whether it is a symmetry plane
                    //
                    // Checking if the plane contains OXYZ is done as follows.
                    // Given a plane (A, B, C, D), it's equation reads
                    // Ax+By+Cz+D=0, where:
                    //  n = (A, B, C) is a vector orthogonal to the plane
                    //  v is a point in the plane
                    //  and D = -dot(n,v)
                    // Obviously, iff D = 0 then the plane contains the point
                    // (0,0,0)

                    const arma::vec& v_in_pl = midpoint;
                    const arma::vec normal =
                        canonic(normalise(midpoint - first, 2));
                    const arma::vec& plane = normal;
                    const double D = -arma::dot(v_in_pl, normal);
                    // check whether the plane passes through OXYZ
                    if (std::abs(D) < tol_dist)
                        if (are_equivalent(coords,
                                           reflect_perp_plane(coords, normal),
                                           q,
                                           tol_dist)) {
                            sigma_planes.insert(plane);
                        }

                    // look for axes
                    for (unsigned k = j + 1; k < coords_len; ++k) {
                        const arma::vec& third = coords.col(k);
                        if (!is_triple_linear(first, second, third, tol_dist)) {
                            // Find the plane containing that triangle and the
                            // vector normal to that plane passing through
                            // (0,0,0). Such vector is to be checked for the
                            // existance of Cn.
                            const arma::vec normal_vec = canonic(
                                get_normal_vector(first, second, third));

                            for (int n = 8; n > 2; --n) {
                                // check for Cn
                                Cn_axis_info axis_info = {normal_vec, n};
                                if (are_equivalent(
                                        coords,
                                        rotate_axis_angle(coords, axis_info),
                                        q,
                                        tol_dist)) {
                                    Cn_axes.insert(axis_info);
                                    // print_symm_elements(Cn_axes,
                                    // sigma_planes);
                                }

                                // check for Sn
                                axis_info.fold = -n;
                                if (are_equivalent(
                                        coords,
                                        rotate_axis_angle(coords, axis_info),
                                        q,
                                        tol_dist)) {
                                    Cn_axes.insert(axis_info);
                                    // print_symm_elements(Cn_axes,
                                    // sigma_planes);
                                }

                                // check for S2n
                                axis_info.fold = -2 * n;
                                if (are_equivalent(
                                        coords,
                                        rotate_axis_angle(coords, axis_info),
                                        q,
                                        tol_dist)) {
                                    Cn_axes.insert(axis_info);
                                    // print_symm_elements(Cn_axes,
                                    // sigma_planes);
                                }
                            }
                        } else {
                            // colinear triple
                        }
                    }
                }
            }

            // finally, check for inversion
            if (are_equivalent(coords, inverse(coords), q, tol_dist)) {
                std::vector<double> axis_buf(3, 0.);
                axis_buf[2] = 1;
                const Cn_axis_info axis_info = {
                    arma::vec(axis_buf), // arbitrary, "Z" by convention.
                    -2};

                Cn_axes.insert(axis_info);
            }

            // add identity E == C1
            std::vector<double> axis_buf(3, 0.);
            axis_buf[2] = 1;
            const Cn_axis_info axis_info = {arma::vec(axis_buf), 1};
            Cn_axes.insert(axis_info);
            _symmetry_group = &find_finite_group(Cn_axes, sigma_planes);
            _rotation_to_std_frame = tacc.get();
        }
    }
}
